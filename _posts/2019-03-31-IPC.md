---
layout: post
title: å°ç™½ç¬”è®° - è¿›ç¨‹é—´é€šä¿¡
author: enh6
categories: blog
---

è¿›ç¨‹é—´é€šä¿¡(IPC)æ˜¯é¢è¯•å¸¸é—®çš„ä¸€ä¸ªæ¦‚å¿µã€‚æ›¾ç»æˆ‘ä¹Ÿåªä¼šåƒæŠ¥èœåä¸€æ ·ï¼Œç®€å•åˆ—ä¸¾ä¸€ä¸‹IPCçš„å‡ ç§æ–¹å¼ï¼šç®¡é“ã€FIFOã€æ¶ˆæ¯é˜Ÿåˆ—ã€å…±äº«å†…å­˜ã€socketã€ä¿¡å·......ä½†ç°åœ¨ï¼Œæˆ‘å‘è§‰å…‰æŠ¥èœåå¹¶ä¸å¤Ÿï¼Œè¿˜æ˜¯éœ€è¦è®²ä¸€äº›æ›´æ·±å…¥çš„ä¸œè¥¿ã€‚èƒ½å¹ä¸ŠåŠä¸ªé’Ÿå¤´ï¼ŒæŠŠäººç»™å”¬çš„ä¸€æ„£ä¸€æ„£çš„ï¼Œæ‰æ˜¯æœ¬äº‹ğŸ˜‚ã€‚

å› æ­¤æˆ‘å°±ä»¥Linuxç³»ç»Ÿå’ŒPOSIXæ¥å£ä½œä¸ºå­¦ä¹ å¯¹è±¡ï¼Œé‡æ–°äº†è§£äº†ä¸€ä¸‹IPCçš„çŸ¥è¯†ï¼Œä¸»è¦å‚è€ƒèµ„æ–™ä¸º[ã€ŠUNIXç¯å¢ƒé«˜çº§ç¼–ç¨‹ç¬¬3ç‰ˆã€‹](https://book.douban.com/subject/25900403/)(ä»¥ä¸‹ç®€ç§°ä¸ºAPUE)ï¼ŒLinuxæ‰‹å†Œä»¥åŠç»´åŸºç™¾ç§‘ï¼Œå¹¶å°è¯•å¯»æ‰¾ä¸€äº›å®é™…é¡¹ç›®ä¸­IPCä½¿ç”¨çš„ä¾‹å­ã€‚ï¼ˆæœ‰äº›æ²¡æ‰¾åˆ°ã€‚ã€‚ï¼‰æœ¬æ–‡ç®—æ˜¯æˆ‘çš„å­¦ä¹ ç¬”è®°å’Œæ€»ç»“ã€‚

## ä¿¡å·(signal)

ä¿¡å·æ˜¯å‘é€ç»™ä¸€ä¸ªè¿›ç¨‹çš„å¼‚æ­¥çš„é€šçŸ¥ã€‚ä¿¡å·æœ‰å‡ åç§ä¸åŒç±»å‹ï¼Œåå­—ä»¥SIGå¼€å¤´ï¼Œå®šä¹‰ä¸ºæ­£æ•´æ•°å¸¸é‡ï¼Œç®—æ˜¯ä¸€ç§èƒ½åŠ›æœ‰é™çš„IPCæ–¹å¼ã€‚å…·ä½“ä»‹ç»å‚è§APUEç¬¬10ç« å’ŒLinuxæ‰‹å†Œsignal(7)ã€‚

#### ä¿¡å·äº§ç”Ÿ

- ç”¨æˆ·ç»ˆç«¯æ“ä½œã€‚å¦‚`Ctrl+C`ä¼šäº§ç”Ÿç»ˆç«¯ä¸­æ–­ä¿¡å·(`SIGINT`)ï¼Œå¸¸ç”¨æ¥ç»ˆæ­¢å‰å°è¿›ç¨‹ã€‚`Ctrl+Z`ä¼šäº§ç”Ÿç»ˆç«¯åœæ­¢ä¿¡å·(`SIGTSTP`)ï¼Œå¸¸ç”¨æ¥æŒ‚èµ·å‰å°è¿›ç¨‹ï¼Œç„¶åå¯ä»¥ç”¨`fg`/`bg`å‘½ä»¤æ¢å¤è¿›ç¨‹æ‰§è¡Œã€‚
- å¼‚å¸¸äº§ç”Ÿä¿¡å·ã€‚å¦‚è¿›ç¨‹æ®µé”™è¯¯ä¼šäº§ç”Ÿ`SIGSEGV`ä¿¡å·ã€‚
- ç³»ç»Ÿè°ƒç”¨`kill`(2)ã€‚
- ç”¨æˆ·å‘½ä»¤`kill`(1)ã€‚å¦‚`kill -9 pid`å‘é€`SIGKILL`æ€è¿›ç¨‹ã€‚
- å…¶ä»–ã€‚å¦‚`alarm`(2)å®šæ—¶å™¨è¶…æ—¶ä¼šäº§ç”Ÿ`SIGALRM`ä¿¡å·ã€‚

#### ä¿¡å·å¤„ç†

- æ•æ‰ä¿¡å·ã€‚ç³»ç»Ÿè°ƒç”¨`signal`(2)æˆ–`sigaction`(2)æ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ã€‚`pause`(2)ä½¿è¿›ç¨‹æŒ‚èµ·ç›´åˆ°æ•æ‰åˆ°ä¿¡å·ã€‚`SIGKILL`å’Œ`SIGSTOP`ä¸èƒ½æ•æ‰ã€‚
- æ‰§è¡Œç³»ç»Ÿé»˜è®¤æ“ä½œã€‚æŠŠä¿¡å·å¤„ç†å‡½æ•°è®¾ä¸º`SIG_DFL`ã€‚é»˜è®¤æ“ä½œå¤§å¤šæ˜¯ç»ˆæ­¢è¿›ç¨‹ã€‚
- å¿½ç•¥ã€‚æŠŠä¿¡å·å¤„ç†å‡½æ•°è®¾ä¸º`SIG_IGN`ã€‚`SIGKILL`å’Œ`SIGSTOP`ä¸èƒ½å¿½ç•¥ã€‚
- é˜»å¡ã€‚`sigprocmask`(2)ã€‚

#### Cè¯­è¨€æ¥å£

```c
int kill(pid_t pid, int signo);
int raise(int signo); // ç­‰äº kill(getpid(), signo)
unsigned int alarm(unsigned int seconds);
int pause(void);
void (*signal(int signo, void (*func) (int)))(int);
int sigaction(int signo, const struct sigaction *restrict act,
    struct sigaction *restrict oact);
```

#### ä¾‹å­

- `abort`(3), `system`(3), `sleep`(3)çš„å®ç°å‡ç”¨åˆ°äº†ä¿¡å·ã€‚

glibcçš„[`abort()`å®ç°](https://github.com/bminor/glibc/blob/master/stdlib/abort.c)å°±æ˜¯å…ˆæŠŠ`SIGABRT`çš„é˜»å¡å»é™¤ï¼š
```
sigset_t sigs;
sigemptyset (&sigs);
sigaddset (&sigs, SIGABRT);
sigprocmask (SIG_UNBLOCK, &sigs, 0);
```
ç„¶åæ‰§è¡Œ`raise(SIGABRT)`ã€‚å¦‚æœç”¨æˆ·æ³¨å†Œäº†`SIGABRT`ä¿¡å·å¤„ç†å‡½æ•°ï¼Œè¿™ä¼šæ‰§è¡Œç”¨æˆ·æ³¨å†Œçš„å‡½æ•°ï¼Œæ‰€ä»¥éœ€è¦æŠŠç”¨æˆ·æ³¨å†Œçš„å»é™¤ï¼Œæ¢æˆé»˜è®¤çš„ï¼š
```c
struct sigaction act;
memset (&act, '\0', sizeof (struct sigaction));
act.sa_handler = SIG_DFL;
sigfillset (&act.sa_mask);
act.sa_flags = 0;
sigaction (SIGABRT, &act, NULL);
```
ç„¶åå†æ‰§è¡Œ`raise(SIGABRT)`ã€‚

- Chromiumå¦‚ä½•å¤„ç†`SIGINT`ç­‰ä¿¡å·ã€‚

POSIXç¯å¢ƒä¸­ï¼ŒChromiumä¹Ÿæ˜¯[é€šè¿‡`sigaction`æ¥å¤„ç†`SIGINT`ç­‰ä¿¡å·](https://github.com/chromium/chromium/blob/master/chrome/app/shutdown_signal_handlers_posix.cc)ï¼Œåœ¨ä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰§è¡Œä¸€äº›æµè§ˆå™¨å…³é—­æ‰€éœ€çš„æ“ä½œï¼š

```c++
// We need to handle SIGTERM, because that is how many POSIX-based distros
// ask processes to quit gracefully at shutdown time.
struct sigaction action;
memset(&action, 0, sizeof(action));
action.sa_handler = SIGTERMHandler;
CHECK_EQ(0, sigaction(SIGTERM, &action, nullptr));

// Also handle SIGINT - when the user terminates the browser via Ctrl+C. If
// the browser process is being debugged, GDB will catch the SIGINT first.
action.sa_handler = SIGINTHandler;
CHECK_EQ(0, sigaction(SIGINT, &action, nullptr));

// And SIGHUP, for when the terminal disappears. On shutdown, many Linux
// distros send SIGHUP, SIGTERM, and then SIGKILL.
action.sa_handler = SIGHUPHandler;
CHECK_EQ(0, sigaction(SIGHUP, &action, nullptr));
```

## ç®¡é“(pipe)

ç®¡é“ï¼Œä¹Ÿå°±æ˜¯åŒ¿åç®¡é“ï¼Œæ˜¯UNIXç³»ç»Ÿæœ€å¤è€çš„IPCå½¢å¼ï¼Œå…·ä½“ä»‹ç»å‚è§APUEç¬¬15ç« 2è‡³3èŠ‚å’ŒLinuxæ‰‹å†Œpipe(7)ã€‚

ç®¡é“æœ‰ä¸¤ä¸ªå±€é™ï¼š1. ç®¡é“æ˜¯åŠåŒå·¥çš„ï¼Œæ•°æ®åªèƒ½åœ¨ä¸€ä¸ªæ–¹å‘ä¸ŠæµåŠ¨ã€‚2. ç®¡é“åªèƒ½åœ¨å…·æœ‰å…¬å…±ç¥–å…ˆçš„ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´ä½¿ç”¨ã€‚

#### åˆ›å»ºç®¡é“

- ç®¡é“é€šè¿‡`pipe`(2)åˆ›å»ºï¼š
```c
int pipe(int fd[2]);
```
`fd`è¿”å›ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œ`fd[1]`ä¸ºå†™ï¼Œ`fd[0]`ä¸ºè¯»ã€‚é€šå¸¸è¿›ç¨‹ä¼šå…ˆè°ƒç”¨`pipe`å†è°ƒç”¨`fork`ï¼Œåˆ›å»ºçˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹ä¹‹é—´çš„IPCé€šé“ã€‚

- `popen`(3)å¯ä»¥åˆ›å»ºç®¡é“ï¼Œæ‰§è¡Œshellå‘½ä»¤ï¼Œå¹¶é€šè¿‡ç®¡é“è¿æ¥å…¶æ ‡å‡†è¾“å…¥æˆ–è€…è¾“å‡ºï¼š
```c
FILE *popen(const char *cmdstring, const char *type);
int pclose(FILE* fp);
```

- Shellä¸­å¯ä»¥ç”¨`|`æ¥åˆ›å»ºä¸€ä¸ªä»å·¦è¾¹çš„æ ‡å‡†è¾“å…¥åˆ°å³è¾¹çš„æ ‡å‡†è¾“å‡ºçš„ç®¡é“

#### ä¾‹å­

ç®¡é“åœ¨Shellä¸­å¾ˆå¸¸è§ã€‚å¦‚ç®€å•çš„ç»Ÿè®¡ï¼š`cat xxx | sort | uniq -c | sort -rg | less`ã€‚

## å‘½åç®¡é“(FIFO)

FIFOæ˜¯ä¸€ç§æ–‡ä»¶ç±»å‹ï¼Œä¸ç®¡é“ç›¸æ¯”ï¼ŒFIFOå¯ä»¥åœ¨ä»»æ„ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´ä¼ é€æ•°æ®ã€‚å…·ä½“ä»‹ç»å‚è§APUEç¬¬15ç« 5èŠ‚å’ŒLinuxæ‰‹å†Œfifo(7)ã€‚

#### åˆ›å»ºå‘½åç®¡é“
- Cæ¥å£`mkfifo`(3)
```c
int mkfifo(const char *path, mode_t mode);
```
- ç”¨æˆ·å‘½ä»¤`mkfifo`(1)

ä½¿ç”¨FIFOå’Œä½¿ç”¨æ™®é€šæ–‡ä»¶ä¸€æ ·ï¼Œå…ˆopenï¼Œå†read/writeã€‚å¦‚é€šè¿‡å¤šä¸ªå®¢æˆ·è¿›ç¨‹å‘ä¸€ä¸ªFIFOå†™ï¼Œä¸€ä¸ªæœåŠ¡å™¨è¿›ç¨‹ä»FIFOè¯»æ¥é€šä¿¡ã€‚

#### ä¾‹å­

æ²¡æ‰¾åˆ°ã€‚

## System V IPC / POSIX IPC

ä¸‹é¢çš„ä¸‰ç§IPCæ–¹å¼ï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ï¼Œä¿¡å·é‡ï¼Œå…±äº«å†…å­˜ï¼‰åœ¨UNIXä¸Šæœ‰ä¸¤å¥—å®ç°ï¼šSystem V IPCå’ŒPOSIX IPCã€‚System V IPCé¡¾åæ€ä¹‰æ¥æºäºSystem Vç³»ç»Ÿï¼Œæ¯”è¾ƒå¤è€ï¼ŒAPUEä¸­ç§°ä¹‹ä¸ºXSI IPCï¼Œå…·ä½“ä»‹ç»å‚è§ç¬¬15ç« 6åˆ°9èŠ‚ã€‚POSIX IPCå‡ºç°çš„æ—¶é—´æ›´æ™šï¼Œæ¥å£æ›´ç®€å•ï¼Œç›®å‰ç½‘ä¸Šä¹Ÿ[æ¨èç”¨POSIX IPC](https://stackoverflow.com/questions/4582968/system-v-ipc-vs-posix-ipc)ï¼Œæ‰€ä»¥ä¸‹é¢å°±ä»¥POSIX IPCæ¥å£ä¸ºä¾‹æ¥çœ‹è¿™ä¸‰ç§IPCæ–¹å¼ã€‚

## æ¶ˆæ¯é˜Ÿåˆ—(message queue)

æ¶ˆæ¯é˜Ÿåˆ—æ˜¯ä¸€ç§å¼‚æ­¥çš„IPCæ–¹å¼ï¼Œå‘é€æ–¹æŠŠæ¶ˆæ¯å­˜æ”¾åˆ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œç›´åˆ°æ¥æ”¶æ–¹å–å‡ºæ¶ˆæ¯ã€‚å…·ä½“ä»‹ç»å‚è§Linuxæ‰‹å†Œmq_overview(7)ã€‚

- åˆ›å»º/æ‰“å¼€æ¶ˆæ¯é˜Ÿåˆ—ï¼š`mq_open`(3)ï¼Œæ¶ˆæ¯é˜Ÿåˆ—çš„åå­—æ˜¯ä»¥æ–œæ å¼€å¤´çš„å­—ç¬¦ä¸²`/somename`ã€‚
- å‘é€/æ¥æ”¶æ¶ˆæ¯ï¼š`mq_send`(3)ï¼Œ`mq_receive`(3)
- æ¶ˆæ¯å¼‚æ­¥é€šçŸ¥ï¼š`mq_notify`(3)ï¼Œæ³¨å†Œå›è°ƒå‡½æ•°ï¼Œåœ¨æœ‰æ–°çš„æ¶ˆæ¯æ¥çš„æ—¶å€™æ‰§è¡Œã€‚

```c
#include <mqueue.h>
mqd_t mq_open(const char *name, int oflag, mode_t mode, struct mq_attr *attr);
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned int msg_prio);
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned int *msg_prio);
int mq_close(mqd_t mqdes);
int mq_unlink(const char *name); // åˆ é™¤æ¶ˆæ¯é˜Ÿåˆ—
```

#### ä¾‹å­

æ²¡æ‰¾åˆ°ã€‚

## <del>ä¿¡å·é‡(semaphore)</del>

ä¿¡å·é‡å®é™…ä¸Šæ˜¯åŒæ­¥åŸè¯­è€Œ**ä¸æ˜¯IPC**ï¼Œç”¨äºå…±äº«èµ„æºçš„åŒæ­¥è®¿é—®ã€‚åªèƒ½ç”¨äºè¿›ç¨‹/çº¿ç¨‹ä¹‹é—´çš„åŒæ­¥ï¼Œæ²¡æ³•ä¼ é€’æ•°æ®ã€‚å…·ä½“ä»‹ç»å‚è§APUEç¬¬15ç« 10èŠ‚å’ŒLinuxæ‰‹å†Œsem_overview(7)ã€‚

- åˆ›å»º/æ‰“å¼€ä¿¡å·é‡ï¼š`sem_open`(3)ï¼Œä¿¡å·é‡çš„åå­—æ˜¯ä»¥æ–œæ å¼€å¤´çš„å­—ç¬¦ä¸²`/somename`ã€‚`sem_init`(3)åˆ›å»ºæœªå‘½åä¿¡å·é‡ã€‚
- ä¿¡å·é‡å‡1æ“ä½œï¼Œwait(P)ï¼š`sem_wait`(3)ï¼Œ`sem_trywait`(3)
- ä¿¡å·é‡åŠ 1æ“ä½œï¼Œsignal(V)ï¼š`sem_post`(3)

```c
#include <semaphore.h>
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
int sem_init(sem_t *sem, int pshared, unsigned int value);
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_post(sem_t *sem);
int sem_close(sem_t *sem);
int sem_unlink(const char *name); // åˆ é™¤å‘½åä¿¡å·é‡
int sem_destroy(sem_t *sem); // é”€æ¯æœªå‘½åä¿¡å·é‡
```

## å…±äº«å†…å­˜(shared memory)

å…±äº«å†…å­˜èƒ½è®©å¤šä¸ªè¿›ç¨‹åŒæ—¶è®¿é—®åŒä¸€å—å†…å­˜ï¼Œæ˜¯ä¸€ç§é«˜æ•ˆçš„æ•°æ®ä¼ é€’æ–¹å¼ã€‚å…·ä½“ä»‹ç»å‚è§Linuxæ‰‹å†Œshm_overview(7)ã€‚

- åˆ›å»º/æ‰“å¼€å…±äº«å†…å­˜ï¼š`shm_open`(3)ï¼Œå…±äº«å†…å­˜çš„åå­—æ˜¯ä»¥æ–œæ å¼€å¤´çš„å­—ç¬¦ä¸²`/somename`ã€‚ç”¨`ftruncate`(2)è®¾ç½®å…±äº«å†…å­˜çš„å¤§å°ã€‚
- æ˜ å°„åˆ°å†…å­˜ç©ºé—´ï¼š`mmap`(2)

```c
#include <sys/mman.h>
int shm_open(const char *name, int oflag, mode_t mode);
int shm_unlink(const char *name);
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
```

Linuxè¿˜ä»¥tmpfsçš„å½¢å¼åœ¨`/dev/shm`æä¾›äº†å…±äº«å†…å­˜çš„æ¥å£ï¼Œ`df -h`å‘½ä»¤å¯ä»¥çœ‹åˆ°å…¶ä½¿ç”¨æƒ…å†µã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä¸ç”¨shm_*å‡½æ•°ï¼Œç›´æ¥åœ¨è¿™ä¸ªç›®å½•ä¸‹åˆ›å»ºæ–‡ä»¶ï¼Œç„¶å`mmap`æ¥ä½¿ç”¨å…±äº«å†…å­˜ã€‚

#### ä¾‹å­

Chromiumåœ¨POSIXç¯å¢ƒä¸‹[åˆ›å»ºå…±äº«å†…å­˜çš„æ–¹å¼](https://github.com/chromium/chromium/blob/master/base/memory/platform_shared_memory_region_posix.cc)å°±æ˜¯åœ¨`/dev/shm`ç›®å½•åˆ›å»ºæ–‡ä»¶ï¼Œç„¶å`ftruncate`è®¾ç½®å¤§å°:

```c++
PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode, size_t size) {
  if (size == 0)
    return {};

  if (size > static_cast<size_t>(std::numeric_limits<int>::max()))
    return {};

  CHECK_NE(mode, Mode::kReadOnly) << "Creating a region in read-only mode will "
                                     "lead to this region being non-modifiable";

  // This function theoretically can block on the disk, but realistically
  // the temporary files we create will just go into the buffer cache
  // and be deleted before they ever make it out to disk.
  ThreadRestrictions::ScopedAllowIO allow_io;

  // We don't use shm_open() API in order to support the --disable-dev-shm-usage
  // flag.
  FilePath directory;
  if (!GetShmemTempDir(false /* executable */, &directory))
    return {};

  ScopedFD fd;
  FilePath path;
  fd.reset(CreateAndOpenFdForTemporaryFileInDir(directory, &path));

  if (!fd.is_valid()) {
    PLOG(ERROR) << "Creating shared memory in " << path.value() << " failed";
    FilePath dir = path.DirName();
    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {
      PLOG(ERROR) << "Unable to access(W_OK|X_OK) " << dir.value();
      if (dir.value() == "/dev/shm") {
        LOG(FATAL) << "This is frequently caused by incorrect permissions on "
                   << "/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix.";
      }
    }
    return {};
  }

  // Deleting the file prevents anyone else from mapping it in (making it
  // private), and prevents the need for cleanup (once the last fd is
  // closed, it is truly freed).
  ScopedPathUnlinker path_unlinker(&path);

  ScopedFD readonly_fd;
  if (mode == Mode::kWritable) {
    // Also open as readonly so that we can ConvertToReadOnly().
    readonly_fd.reset(HANDLE_EINTR(open(path.value().c_str(), O_RDONLY)));
    if (!readonly_fd.is_valid()) {
      DPLOG(ERROR) << "open(\"" << path.value() << "\", O_RDONLY) failed";
      return {};
    }
  }

  // Get current size.
  struct stat stat = {};
  if (fstat(fd.get(), &stat) != 0)
    return {};
  const size_t current_size = stat.st_size;
  if (current_size != size) {
    if (HANDLE_EINTR(ftruncate(fd.get(), size)) != 0)
      return {};
  }

  if (readonly_fd.is_valid()) {
    struct stat readonly_stat = {};
    if (fstat(readonly_fd.get(), &readonly_stat))
      NOTREACHED();

    if (stat.st_dev != readonly_stat.st_dev ||
        stat.st_ino != readonly_stat.st_ino) {
      LOG(ERROR) << "Writable and read-only inodes don't match; bailing";
      return {};
    }
  }

  return PlatformSharedMemoryRegion({std::move(fd), std::move(readonly_fd)},
                                    mode, size, UnguessableToken::Create());
}
```

## ç½‘ç»œå¥—æ¥å­—(socket)

Socketæ˜¯é€šè¿‡IPåè®®ï¼Œå¯ä»¥åœ¨ä¸åŒçš„è®¡ç®—æœºä¹‹é—´è¿›è¡Œé€šä¿¡çš„æ–¹å¼ã€‚å…·ä½“ä»‹ç»å‚è§APUEç¬¬16ç« å’ŒLinuxæ‰‹å†Œsocket(7)ã€‚

Unixç½‘ç»œç¼–ç¨‹æ˜¯ä¸€ä¸ªå¾ˆå¤§çš„é¢†åŸŸï¼ŒAPUEçš„ä½œè€…Richard Stevensè¿˜æœ‰å¦ä¸€éƒ¨è‘—ä½œã€ŠUNIXç½‘ç»œç¼–ç¨‹ã€‹ï¼Œç¬¬ä¸€å·ä¸“é—¨è®²çš„socketï¼Œç¬¬äºŒå·ä¸“é—¨è®²çš„å„ç§UNIX IPCã€‚æˆ‘æ²¡çœ‹è¿‡è¿™ä¸¤æœ¬ä¹¦ï¼Œä¹Ÿæ²¡æ€ä¹ˆæ¥è§¦è¿‡LinuxæœåŠ¡å™¨åç«¯è¿™å—ï¼Œæ‰€ä»¥è¿™é‡Œåªç®€å•å†™ä¸€ä¸‹ã€‚

#### åˆ›å»ºsocketè¿æ¥

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

`socket`(3)åˆ›å»ºsocketã€‚å‚æ•°`domain`ç¡®å®šé€šä¿¡ä½¿ç”¨çš„åè®®æ—ï¼Œå¦‚`AF_INET`æ˜¯IPv4åè®®ï¼Œ`AF_INET6`æ˜¯IPv6åè®®ã€‚å‚æ•°`type`ç¡®å®šsocketçš„ç±»å‹ï¼Œå¦‚`SOCK_DGRAM`(å›ºå®šé•¿åº¦æ— è¿æ¥ä¸å¯é æŠ¥æ–‡)å’Œ`SOCK_STREAM`(æœ‰åºå¯é åŒå‘é¢å‘è¿æ¥çš„å­—èŠ‚æµ)ã€‚å‚æ•°`protocol`ç¡®å®šå…·ä½“åè®®ï¼Œä¼ å…¥`0`è¡¨ç¤ºé€‰æ‹©é»˜è®¤çš„åè®®ã€‚å¦‚`AF_INET`ä¸‹ï¼Œ`SOCK_DGRAM`çš„é»˜è®¤åè®®æ˜¯UDP(`IPPROTO_UDP`)ï¼Œ`SOCK_STREAM`çš„é»˜è®¤åè®®æ˜¯TCP(`IPPROTO_TCP`)ã€‚å‡½æ•°è¿”å›å€¼ä¸ºsocketæè¿°ç¬¦ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€‚

`bind`(2)å°†socketä¸ä¸€ä¸ªåœ°å€å…³è”ã€‚IPv4åè®®åœ°å€å°±æ˜¯IPåŠ ç«¯å£å·äº†ã€‚

é¢å‘è¿æ¥çš„åè®®(TCP)éœ€è¦ä¸€ä¸ªè¿æ¥è¿‡ç¨‹ã€‚å®¢æˆ·ç«¯éœ€è¦ç”¨`connect`(2)å»ºç«‹å®¢æˆ·ç«¯çš„socketä¸æœåŠ¡å™¨ç«¯çš„åœ°å€çš„è¿æ¥ã€‚æœåŠ¡å™¨ç«¯ç”¨`listen`(2)ç›‘å¬è¿æ¥è¯·æ±‚ï¼Œå¹¶ç”¨`accept`(2)è·å¾—è¿æ¥è¯·æ±‚å¹¶å»ºç«‹è¿æ¥ã€‚`accept`è¿”å›ä¸€ä¸ªè¿æ¥åˆ°å®¢æˆ·ç«¯çš„æ–°çš„socketã€‚è€ŒåŸæ¥çš„socketä¸å—å½±å“ï¼Œè¿˜åœ¨ç›‘å¬è¯·æ±‚ã€‚

#### æ•°æ®ä¼ è¾“

```c
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```

æœ‰ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨ç”¨æ¥å‘é€æ•°æ®ï¼š`send`ï¼Œ`sendto`å’Œ`sendmsg`ã€‚æœ‰ä¸‰ä¸ªç³»ç»Ÿè°ƒç”¨ç”¨æ¥æ¥æ”¶æ•°æ®ï¼š`recv`ï¼Œ`recvfrom`å’Œ`recvmsg`ã€‚

è°ƒç”¨æ¥æ”¶å‡½æ•°æ²¡æœ‰æ•°æ®å¯ç”¨æ—¶ä¼šé˜»å¡ï¼Œè€Œsocketä¹Ÿæ”¯æŒéé˜»å¡I/Oæ¨¡å‹ã€‚æœåŠ¡å™¨ä¸ºäº†é«˜å¹¶å‘ä¹Ÿæœ‰è®¸å¤šåˆ«çš„I/Oæ¨¡å‹ï¼Œä¸è¿‡è¿™å°±æ˜¯å¦ä¸€ä¸ªè¯é¢˜äº†ã€‚

#### ä¾‹å­

socketæˆ‘å°±ä¸ä¸¾ä¾‹äº†ï¼Œæ‰€æœ‰æœåŠ¡å™¨è½¯ä»¶éƒ½è¦ç”¨è¿™ä¸ªã€‚

## UnixåŸŸå¥—æ¥å­—(Unix domain socket)

Unix domain socketæ˜¯ç”¨äºåŒä¸€å°è®¡ç®—æœºä¸Šçš„IPCã€‚å…¶APIä¸socketç›¸ä¼¼ï¼Œä½†ä¸ç”¨ä½¿ç½‘ç»œåè®®ï¼Œæ•ˆç‡æ›´é«˜ã€‚Unix domain socketä¹Ÿæä¾›äº†å­—èŠ‚æµå’Œæ•°æ®æŠ¥ä¸¤ç§æ¥å£ï¼Œè€Œä¸”å…¶æ•°æ®æŠ¥æœåŠ¡æ˜¯å¯é æœ‰åºçš„ã€‚

#### åˆ›å»ºUnix domain socket

- æœªå‘½åUnix domain socketï¼š`socketpair`(2)åˆ›å»ºä¸€å¯¹æœªå‘½åçš„ç›¸äº’è¿æ¥çš„Unix domain socketã€‚å‚æ•°`domain`åº”è®¾ä¸º`AF_UNIX`ã€‚å‚æ•°`type`å¯ä»¥æ˜¯`SOCK_STREAM`æˆ–è€…`SOCK_DGRAM`ã€‚
```c
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int sockfd[2]);
```
- å‘½åUnix domain socketï¼šä¹Ÿæ˜¯ç”¨`socket`(2)åˆ›å»ºã€‚å‚æ•°`domain`åº”è®¾ä¸º`AF_UNIX`ã€‚å‚æ•°`type`å¯ä»¥æ˜¯`SOCK_STREAM`æˆ–è€…`SOCK_DGRAM`ã€‚ç„¶å`bind`(2)å°†Unix domain socketä¸ä¸€ä¸ªåœ°å€å…³è”ã€‚ä½†è¿™ä¸ªåœ°å€å°±ä¸æ˜¯socketä¸­çš„IPåŠ ç«¯å£å·äº†ï¼Œè€Œæ˜¯ä¸€ä¸ªè·¯å¾„åã€‚`bind`ä¼šåœ¨è¿™ä¸ªè·¯å¾„ååˆ›å»ºä¸€ä¸ª`S_IFSOCK`æ–‡ä»¶ã€‚

Unix domain socketçš„è¿æ¥å’Œæ•°æ®ä¼ è¾“æ˜¯å’Œsocketæ˜¯ä¸€æ ·çš„ã€‚

#### ä¼ è¾“æ–‡ä»¶æè¿°ç¬¦

Unix domain socketæ˜¯ä¸€ç§é«˜çº§çš„IPCæ–¹å¼ï¼Œé«˜çº§çš„ä¸€ç‚¹å°±æ˜¯å¯ä»¥ä¼ è¾“æ–‡ä»¶æè¿°ç¬¦ã€‚æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„æ–‡ä»¶è¡¨é¡¹ï¼Œæ‰€ä»¥å‘é€æ–‡ä»¶æè¿°ç¬¦ä¸åªæ˜¯ä¼ è¾“ä¸€ä¸ªintå€¼é‚£ä¹ˆç®€å•ï¼Œè€Œæ˜¯éœ€è¦å†…æ ¸å¤„ç†çš„ã€‚

#### ä¾‹å­

Chromiumçš„IPCåº“[mojo](https://github.com/chromium/chromium/tree/master/mojo)åœ¨POSIXç¯å¢ƒä¸‹å°±ä¸»è¦[ä½¿ç”¨Unix domain socket](https://github.com/chromium/chromium/blob/master/mojo/public/cpp/platform/platform_channel.cc)ä½œä¸ºIPCçš„æ–¹å¼ï¼š

```c++
#elif defined(OS_POSIX)
void CreateChannel(PlatformHandle* local_endpoint, PlatformHandle* remote_endpoint) {
  int fds[2];
  PCHECK(socketpair(AF_UNIX, SOCK_STREAM, 0, fds) == 0);
  // Set non-blocking on both ends.
  PCHECK(fcntl(fds[0], F_SETFL, O_NONBLOCK) == 0);
  PCHECK(fcntl(fds[1], F_SETFL, O_NONBLOCK) == 0);
  *local_endpoint = PlatformHandle(base::ScopedFD(fds[0]));
  *remote_endpoint = PlatformHandle(base::ScopedFD(fds[1]));
  DCHECK(local_endpoint->is_valid());
  DCHECK(remote_endpoint->is_valid());
}
#endif
```
